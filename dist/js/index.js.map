{"version":3,"sources":["index.js"],"names":["setup","snake","x","Math","floor","FIELD_WIDTH","y","FIELD_HEIGHT","direction","random","fruit","score","drawScore","time","canTurn","scoreCounter","html","highScore","highScoreCounter","draw","context","strokeStyle","fillStyle","clearRect","canvas","width","height","strokeRect","fillCircle","CELL_SIZE","cell","i","prevLastX","_","last","prevLastY","prevLastDirection","head","length","clearInterval","gameLoopInterval","timeUpdateInterval","blinkingIsVisible","blinkingInterval","setInterval","fillRect","SNAKE_BLINKING_INTERVAL_MS","setTimeout","youDiedModalScore","youDiedModalTime","youDiedModal","modal","SNAKE_BLINKING_TIME_MS","normalizeCoord","push","nextCell","coord","maxValue","runGame","timeCounter","GAME_LOOP_INTERVAL_MS","document","getElementById","getContext","$","leaderboard","youDiedModalPlayerName","CANVAS_TO_PARENT_SIZE_PROPORTION","parent","window","on","debounce","KEY_CODES","leftArrow","upArrow","rightArrow","downArrow","w","a","s","d","enter","focus","name","val","isEmpty","prepend","keyup","evt","keyCode","radius","this","beginPath","centerX","centerY","arc","PI","fill","body"],"mappings":"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","file":"index.js","sourcesContent":["/*\n * Copyright (c) 2017 Dmytro Meleshko\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* global _ */\n\n'use strict';\n\nvar canvas = document.getElementById('canvas'),\n    context = canvas.getContext('2d'),\n    scoreCounter = $('#score-counter'),\n    highScoreCounter = $('#high-score-counter'),\n    timeCounter = $('#time-counter'),\n    leaderboard = $('#leaderboard > tbody'),\n    youDiedModal = $('#you-died-modal'),\n    youDiedModalPlayerName = $('#you-died-modal #player-name'),\n    youDiedModalScore = $('#you-died-modal #statistics-score'),\n    youDiedModalTime = $('#you-died-modal #statistics-time'),\n    gameLoopInterval, timeUpdateInterval;\n\nvar CANVAS_TO_PARENT_SIZE_PROPORTION = 1.1;\ncanvas.height = canvas.width = $(canvas).parent().width() / CANVAS_TO_PARENT_SIZE_PROPORTION;\n\nvar FIELD_WIDTH = 30, // Field width in cells\n    FIELD_HEIGHT = 30, // Field height in cells\n    CELL_SIZE = canvas.width / FIELD_WIDTH,\n    GAME_LOOP_INTERVAL_MS = 100,\n    SNAKE_BLINKING_INTERVAL_MS = 150, // Snake blinks after death\n    SNAKE_BLINKING_TIME_MS = 2000; // How many snake will be blinking\n\n// Adding responsivity for canvas\n$(window).on('resize', _.debounce(function() {\n    // Size values are recalculated on each resize\n    canvas.height = canvas.width = $(canvas).parent().width() / CANVAS_TO_PARENT_SIZE_PROPORTION;\n    CELL_SIZE = canvas.width / FIELD_WIDTH;\n}, GAME_LOOP_INTERVAL_MS));\n\nvar KEY_CODES = {\n    leftArrow: 37,\n    upArrow: 38,\n    rightArrow: 39,\n    downArrow: 40,\n    w: 87,\n    a: 65,\n    s: 83,\n    d: 68,\n    enter: 13\n};\n\n// Setting up \"You Died!\" modal\nyouDiedModal.on('shown.bs.modal', function() {\n    youDiedModalPlayerName.focus();\n});\nyouDiedModal.on('hidden.bs.modal', function() {\n    var name = youDiedModalPlayerName.val();\n    if (!_.isEmpty(name))\n        leaderboard.prepend(\n            '<tr>' +\n            '<td>' + name + '</td>' +\n            '<td>' + score + '</td>' +\n            '<td>' + time + ' sec</td>' +\n            '</tr>');\n    youDiedModalPlayerName.val('');\n    runGame();\n});\n// Setting up \"You Died!\" modal's player name text field\nyouDiedModalPlayerName.keyup(function(evt) {\n    if (evt.keyCode == KEY_CODES.enter)\n        youDiedModal.modal('hide');\n});\n\ncontext.fillCircle = function fillCircle(x, y, radius) {\n    this.beginPath();\n    var centerX = x * CELL_SIZE + radius;\n    var centerY = y * CELL_SIZE + radius;\n    this.arc(centerX, centerY, radius, 0, 2 * Math.PI);\n    this.fill();\n};\n\n// canTurn is used as fix for this bug: if player presses two keys in one game loop interval, snake can turn around\nvar snake, fruit, score, time, canTurn, highScore = 0;\n\n$(document.body).on('keydown', function(evt) {\n    if (canTurn) {\n        canTurn = false;\n        var keyCode = evt.keyCode;\n        var head = _.head(snake);\n        if ((keyCode == KEY_CODES.leftArrow || keyCode == KEY_CODES.a) && head.direction != 'right')\n            head.direction = 'left';\n        else if ((keyCode == KEY_CODES.upArrow || keyCode == KEY_CODES.w) && head.direction != 'down')\n            head.direction = 'up';\n        else if ((keyCode == KEY_CODES.rightArrow || keyCode == KEY_CODES.d) && head.direction != 'left')\n            head.direction = 'right';\n        else if ((keyCode == KEY_CODES.downArrow || keyCode == KEY_CODES.s) && head.direction != 'up')\n            head.direction = 'down';\n    }\n});\n\nfunction setup() {\n    snake = [\n        // First element is the head of the snake\n        {\n            x: Math.floor(FIELD_WIDTH / 2),\n            y: Math.floor(FIELD_HEIGHT / 2),\n            // Getting random direction\n            direction: ['left', 'up', 'right', 'down'][Math.floor(Math.random() * 4)]\n        }\n    ];\n\n    // First fruit will be spawned on random cell\n    fruit = {\n        x: Math.floor(Math.random() * FIELD_WIDTH),\n        y: Math.floor(Math.random() * FIELD_HEIGHT)\n    };\n\n    score = 0;\n    drawScore();\n\n    time = 0;\n    canTurn = true;\n}\n\nfunction drawScore() {\n    scoreCounter.html(score);\n    if (score > highScore)\n        highScore = score;\n    highScoreCounter.html(highScore);\n}\n\nfunction draw() {\n    context.strokeStyle = 'black';\n    context.fillStyle = 'black';\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.strokeRect(0, 0, canvas.width, canvas.height);\n\n    context.fillCircle(fruit.x, fruit.y, CELL_SIZE / 2 - 1);\n\n    // Saving data from previous last cell, to spawn there new cell, if snake eats fruit\n    var prevLastX = _.last(snake).x,\n        prevLastY = _.last(snake).y,\n        prevLastDirection = _.last(snake).direction;\n\n    var head = _.head(snake);\n\n    // Checking if head touches any cell from tail\n    var cell, i;\n    for (i = 1; i < snake.length; i++) {\n        cell = snake[i];\n        if (head.x == cell.x && head.y == cell.y) {\n            clearInterval(gameLoopInterval);\n            clearInterval(timeUpdateInterval);\n\n            var blinkingIsVisible = true;\n            var blinkingInterval = setInterval(function() {\n                context.clearRect(0, 0, canvas.width, canvas.height);\n                context.strokeRect(0, 0, canvas.width, canvas.height);\n\n                if (blinkingIsVisible) {\n                    for (i = 0; i < snake.length; i++) {\n                        cell = snake[i];\n                        context.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\n                    }\n                }\n\n                blinkingIsVisible = !blinkingIsVisible;\n            }, SNAKE_BLINKING_INTERVAL_MS);\n\n            setTimeout(function() {\n                clearInterval(blinkingInterval);\n                youDiedModalScore.html(score);\n                youDiedModalTime.html(time + ' sec');\n                youDiedModal.modal('show');\n            }, SNAKE_BLINKING_TIME_MS);\n\n            return;\n        }\n    }\n\n    for (i = 0; i < snake.length; i++) {\n        cell = snake[i];\n        context.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\n\n        if (cell.direction == 'left') cell.x--;\n        else if (cell.direction == 'up') cell.y--;\n        else if (cell.direction == 'right') cell.x++;\n        else if (cell.direction == 'down') cell.y++;\n\n        cell.x = normalizeCoord(cell.x, FIELD_WIDTH);\n        cell.y = normalizeCoord(cell.y, FIELD_HEIGHT);\n    }\n\n    if (head.x == fruit.x && head.y == fruit.y) {\n        // Adding new cell to tail of the snake\n        snake.push({ x: prevLastX, y: prevLastY, direction: prevLastDirection });\n        // Respawning fruit\n        fruit = {\n            x: Math.floor(Math.random() * FIELD_WIDTH),\n            y: Math.floor(Math.random() * FIELD_HEIGHT)\n        };\n\n        score++;\n        drawScore();\n    }\n\n    // Changing direction of cells\n    for (i = snake.length - 1; i >= 1; i--) {\n        cell = snake[i];\n        var nextCell = snake[i - 1];\n        cell.direction = nextCell.direction;\n    }\n\n    canTurn = true;\n}\n\nfunction normalizeCoord(coord, maxValue) {\n    coord = coord % maxValue;\n    if (coord < 0) coord = maxValue + coord;\n    return coord;\n}\n\nfunction runGame() {\n    setup();\n    timeUpdateInterval = setInterval(function() {\n        timeCounter.html(time + ' sec');\n        time++;\n    }, 1000);\n    gameLoopInterval = setInterval(draw, GAME_LOOP_INTERVAL_MS);\n}\n\nrunGame();\n"],"sourceRoot":"../src/css"}